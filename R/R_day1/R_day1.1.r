


class_mates <- c("Harry", "Sarah", "Kevin", "Paulina", "Samantha")
names(class_mates) <- c("Ruth", "Jimmy", "Kevin", "Paul", "Harry")
names(class_mates)

length(class_mates)
class_mates[c("Ruth", "Kevin")]
class_mates[length(class_mates)]
class_mates[4] <-  "Paula"
class_mates

num <- c(6, 3, 2, 18)
bool <- c(TRUE, FALSE, TRUE, TRUE)
sum(num[bool])
num_2 <- c(3, 4, 12)
num + num_2
missing <- c(9, 4, NA, 2, 43, NA, 4, 2)
bool_missing <- is.na(missing)
sum(bool_missing)

sum(is.na(missing))

6. Generate an ordered factor of length 6. Check the levels of the factor.
Replace element 2 with a value not listed in the levels - note the
warning.

numbers <- factor(c(3, 35, 4, 2, 2, 54), levels = c(3, 23, 4, 54, 2, 5) ordered = TRUE,)
levels(numbers)
min(numbers)
numbers[2] <- 2

quality_factor <- factor(c("medium", "low", "low", "high", "medium"), levels = c("high", "low", "medium"), ordered = TRUE)
quality_factor

7. Make a list containing a character vector, a boolean vector, a factor,
and a numerical vector. Use [[]] or [] to access: (1) the second and
third items in the list, and (2) the second element of the third item in
the list.

my_list <- list(class_mates, bool, numbers)
my_list
names(my_list) <- c("Hi", "ho", "he")
my_list[2:3]
my_list[[3]][[2]]
my_list$he

8. Add names to the list elements. Access list elements using the $
  notation.
see above

9. Change the order of the factor levels inside the list and add a new
level to the factor.



1. Create a numeric vector of length 10. Write an lapply and sapply
statement to square each element. Compare the two outputs.

numeric_vector <- c(1, 4, 6, 20, 8, 54, 78, 1002, 40, 32)

lapply(numeric_vector, function(x) x^2)
sapply(numeric_vector, function(x) x^2)

2. Generate a list of length 4 containing both numeric and logical
vectors. Write an lapply or sapply statement to calculate the sum of
the elements in each vector.

bool <- c(TRUE, FALSE, TRUE, TRUE)
my_list_1 <- list(numeric_vector, bool, numeric_vector, bool)
my_list_1
lapply(my_list_1, sum)
sapply(my_list_1, sum)

3. Write an sapply statement to repeat each element of each vector in
your list three times e.g. 1, 4, 3 would become 1, 1, 1, 4, 4, 4, 3, 3, 3.
Assign the output to a new list.

my_list_2 <- sapply(my_list_1, function(x) rep(x, each =3))
my_list_2

4. Convert your new list into a single vector.

vector <- c(my_list_2[[1]], my_list_2[[2]], my_list_2[[3]], my_list_2[[4]])
vector

vector_2 <- unlist(my_list_2)
vector_2

my_matrix <- matrix(seq(from = 2, to = 100, by = 2), nrow = 5, byrow = TRUE)
View(my_matrix)


2. Using apply, calculate: (1) the sum of squares of each row, and (2) the
min and max of each column

apply(my_matrix, 1, function(x) sum(x^2))
apply(my_matrix, 2, min)
apply(my_matrix, 2, max)
apply(my_matrix, 2, function(x) c(min(x), max(x)))

3. Generate a second matrix containing 10 rows and 6 columns 
-fill with numbers of your choice. Calculate the transpose 
of this matrix. Join the transposed matrix to the matrix 
from #1 (join by row). 
Check the dimensions of your joined matrix.

my_matrix_2 <- matrix(seq(from = 1, to = 60), nrow = 10, ncol = 6)
my_matrix_2
transposed_matrix <- t(my_matrix_2)
dim(transposed_matrix)
dim(my_matrix)
my_matrix_3 <- rbind(my_matrix, transposed_matrix)
my_matrix_3
dim(my_matrix_3)
my_data.df <- as.data.frame(my_matrix_3)
my_data.df
typeof(my_data.df)
class(my_data.df)

my_list <- as.list(my_data.df)
class(my_list)








